
# Hierarchical syntax
Grammar <- Spacing Definition+ Extensions
Definition <- Identifier LEFTARROW Expression
Expression <- Prefix+ (SLASH Prefix+)*
Prefix <- (AND / NOT)? Primary (QUESTION / STAR / PLUS)? 
Primary <- Identifier !LEFTARROW
         / OPEN Expression CLOSE
         / Literal / Class / DOT / ActionExprExt

# Extension Syntax
Extensions <- EOF / (Extension Spacing)* EOF 
Extension <- PrefixExt / ValueExt / AuxilExt / HeaderExt / CCodeExt
PrefixExt <- '%prefix' Spacing Literal
ValueExt <- '%value' Spacing Literal
AuxilExt <- '%auxil' Spacing Literal
HeaderExt <- '%header' Spacing ExtBody Spacing
CCodeExt <- '%%' .* EOF
ExtBody <- '{' Spacing ExtBody '}' Spacing
         / '{' Spacing (!'}' .)+ '}' Spacing
         / '{' Spacing '}' Spacing
#CCOMMENT <- CSLCOMMENT / CMLCOMMENT
#CSLCOMMENT <- '//' (!EOL .)* EOL
#CMLCOMMENT <- '/*' (!'*/' .)* '*/'


ActionExprExt <- '{' Spacing ActionExprExt '}' Spacing /
                 '{' Spacing (!'}' .)* '}' Spacing

# Lexical syntax
EOF <- !.
EOL <- '\r\n' / '\n' / '\r'
SPACE <- ' ' / '\t' / EOL
PEGCOMMENT <- '#' (!EOL .)* EOL
DOT <- '.' Spacing
CLOSE <- ')' Spacing
OPEN <- '(' Spacing
PLUS <- '+' Spacing
STAR <- '*' Spacing
QUESTION <- '?' Spacing
NOT <- '!' Spacing
AND <- '&' Spacing
SLASH <- '/' Spacing
LEFTARROW <- '<-' Spacing
CHAR <- '\\' [nrt'"\[\]\\]
      / '\\' [0-2][0-7][0-7]
      / '\\' [0-7][0-7]?
      / !'\\' .
Spacing <- (SPACE / PEGCOMMENT)*
Range <- CHAR '-' CHAR / CHAR
Class <- '[' '^'? (!']' Range)* ']' Spacing
Literal <- ['] (!['] CHAR)* ['] Spacing
         / ["] (!["] CHAR)* ["] Spacing
IDENTSTART <- [a-zA-Z_]
IDENTCONT <- IDENTSTART / [0-9]
Identifier <- IDENTSTART IDENTCONT* Spacing


%prefix "peg"
%value "ASTNode_t*"
%auxil "auxil_t*"

%header {
#include <daisho/Daisho.h>

#define PCC_GETCHAR(auxil) nextChar(auxil)
#define PCC_BUFFERSIZE (__DAI_PAGESIZE * 10)
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) debugVisit(auxil, event, rule, level)

struct ASTNode_t;
typedef struct ASTNode_t ASTNode_t;
struct ASTNode_t {
  ASTNode_t* parent;
};

typedef struct {
  __Dai_String_View target;
  void* ctx;
} auxil_t;

static inline char nextChar(auxil_t* auxil) {
  if (auxil->target.str[auxil->target.len] == '\0') {
    return EOF;
  } else {
    char ret = auxil->target.str[auxil->target.len];
    auxil->target.len++;
    return ret;
  }
}
static inline void debugVisit(auxil_t* auxil, int event, char* rule, size_t level) {
  if (event != 0) return;
  if (isupper(rule[2])) return;
  for (size_t i = 0; i < level; i++)
    putchar(' ');
  printf("%s\n", rule);
}
}


%%
int main(int argc, char** argv) {

  // Load file
  char* filename = argc == 2 ? argv[1] : "PEG.peg";
  auxil_t auxil;
  auxil.target = __Dai_readFile(filename);
  auxil.target.len = 0;
  printf("Loaded %s\n", filename);

  // Parse ast
  ASTNode_t* ast;
  peg_context_t* ctx = peg_create(&auxil);
  auxil.ctx = ctx;
  int parser_ret = peg_parse(ctx, &ast);
  printf("%i\n", parser_ret);
  peg_destroy(ctx);
  return 0;
}
