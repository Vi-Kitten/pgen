
# Hierarchical syntax
Grammar <- Spacing Definition+ Extensions
Definition <- Identifier LEFTARROW Expression
Expression <- Prefix+ (SLASH Prefix+)*
Prefix <- (AND / NOT)? Primary (QUESTION / STAR / PLUS)?
Primary <- Identifier !LEFTARROW
         / OPEN Expression CLOSE
         / Literal / Class / DOT / CCodeExt

# Extension Syntax
Extensions <- EOF / Spacing (Extension Spacing)* EOF
Extension <- PrefixExt / ValueExt / AuxilExt / HeaderExt / EndCCodeExt
PrefixExt <- '%prefix' Spacing Literal
ValueExt <- '%value' Spacing Literal
AuxilExt <- '%auxil' Spacing Literal
HeaderExt <- '%header' Spacing CCodeExt Spacing
EndCCodeExt <- '%%' (!EOF .)* EOF
CCodeExt <- '{' Spacing (CCOMMENT / &'{' CCodeExt / !'}' .)* '}' Spacing
CCOMMENT <- CSLCOMMENT / CMLCOMMENT
CSLCOMMENT <- '//' (!EOL .)* EOL
CMLCOMMENT <- '/*' (!'*/' .)* '*/'

# Lexical syntax
EOF <- !.
EOL <- '\r\n' / '\n' / '\r'
SPACE <- ' ' / '\t' / EOL
PEGCOMMENT <- '#' (!EOL .)* EOL
DOT <- '.' Spacing
CLOSE <- ')' Spacing
OPEN <- '(' Spacing
PLUS <- '+' Spacing
STAR <- '*' Spacing
QUESTION <- '?' Spacing
NOT <- '!' Spacing
AND <- '&' Spacing
SLASH <- '/' Spacing
LEFTARROW <- '<-' Spacing
CHAR <- '\\' [nrt'"\[\]\\]
      / '\\' [0-2][0-7][0-7]
      / '\\' [0-7][0-7]?
      / !'\\' .
Spacing <- (SPACE / PEGCOMMENT)*
Range <- CHAR '-' CHAR / CHAR
Class <- '[' '^'? (!']' Range)* ']' Spacing
Literal <- ['] (!['] CHAR)* ['] Spacing
         / ["] (!["] CHAR)* ["] Spacing
IDENTSTART <- [a-zA-Z_]
IDENTCONT <- IDENTSTART / [0-9]
Identifier <- IDENTSTART IDENTCONT* Spacing


%prefix "peg"
%value "ASTNode*"
%auxil "auxil_t*"

%header {
/* Depends on but does not initialize the Daisho runtime. */
#include <daisho/Daisho.h>
#include "PEGAST.h"

#define PCC_BUFFERSIZE (__DAI_PAGESIZE * 64)

typedef struct {
  __Dai_String_View target;
  void* ctx;
} auxil_t;

#define PCC_GETCHAR(auxil) nextChar(auxil)
static inline char nextChar(auxil_t* auxil) {
  if (auxil->target.str[auxil->target.len] == '\0') {
    return EOF;
  } else {
    char ret = auxil->target.str[auxil->target.len];
    auxil->target.len++;
    return ret;
  }
}

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) debugVisit(auxil, event, rule, level)
static inline void debugVisit(auxil_t* auxil, int event, char* rule, size_t level) {
  if (isupper(rule[2])) return;

  /* Color eval, accept, reject */
  if (event == 0) printf("%s", __DAI_COLOR_BLUE);
  else if (event == 1) printf("%s", __DAI_COLOR_GREEN);
  else printf("%s", __DAI_COLOR_RED);

  for (size_t i = 0; i < level; i++) printf("%c%c", ' ', ' ');
  printf("%s%s\n", rule, __DAI_COLOR_RESET);
}

#define PCC_ERROR(auxil) debugError(auxil)
static inline void debugError(auxil_t* auxil) {
    puts("Syntax error:");
    puts(auxil->target.str + auxil->target.len);
}

}


%%
int main(int argc, char** argv) {

  // Load target file
  char* filename = argc == 2 ? argv[1] : "PEG.peg";
  auxil_t auxil;
  auxil.target = __Dai_readFile(filename);
  auxil.target.len = 0;

  // Parse ast
  ASTNode* ast;
  peg_context_t* ctx = peg_create(&auxil);
  auxil.ctx = ctx;
  int parser_ret = peg_parse(ctx, &ast);

  peg_destroy(ctx);
  return 0;
}
