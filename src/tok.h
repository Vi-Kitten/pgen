/* A packrat parser generated by PackCC 1.7.1 */

#ifndef PCC_INCLUDED_TOK_H
#define PCC_INCLUDED_TOK_H

#include "pccast.h"
#include "util.h"

// #define PCC_BUFFERSIZE (4096 * 64)

typedef struct {
  String_View target;
  size_t pos;
  void* ctx;
} auxil_t;

#define PCC_GETCHAR(auxil) nextChar(auxil)
static inline char nextChar(auxil_t* auxil) {
  if (auxil->target.str[auxil->pos] == '\0') {
    return EOF;
  } else {
    char ret = auxil->target.str[auxil->pos];
    auxil->pos++;
    return ret;
  }
}

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) debugVisit(auxil, event, rule, level, (size_t)pos, buffer, (size_t)length)
static inline void debugVisit(auxil_t* auxil, int event, char* rule, size_t level, size_t pos, char* buffer, size_t length) {
  for (size_t i = 0; i < level; i++) printf("%c%c", ' ', ' ');
  /* Color eval, accept, reject */
  char* color =  event ? event == 1 ? "\x1b[32m" : "\x1b[31m" : "\x1b[34m";
  printf("%s%s%s\n", color, rule, "\x1b[0m");

/*
  if (event == 1) {
    String_View sv;
    sv.str = buffer;
    sv.len = length;
    printf("%s", color);
    printStringView(sv);
    printf("%s", "\x1b[0m");
  }
*/
}

#define PCC_ERROR(auxil) debugError(auxil)
static inline void debugError(auxil_t* auxil) {
    puts("Syntax error:");
    puts(auxil->target.str + auxil->pos);
}
#ifdef __cplusplus
extern "C" {
#endif

typedef struct tok_context_tag tok_context_t;

tok_context_t *tok_create(auxil_t*auxil);
int tok_parse(tok_context_t *ctx, ASTNode**ret);
void tok_destroy(tok_context_t *ctx);

#ifdef __cplusplus
}
#endif

#endif /* !PCC_INCLUDED_TOK_H */
