# Note - This is written in normal PEG fashion, for my own understanding.
# This is not an example of the usage of pgen, it is different.

# Operators:
# /  - Try to match the left side, then try to match the right side.
# &  - Try to parse, match but rewind.
# !  - Try to parse, match if doesn't match.
# ?  - Optionally match. Failure to match does not cause the rule to fail.
# *  - Match zero or more. Returns a list of matches.
# +  - Match one or more. Returns a list of matches.
# () - Matches if all expressions within match.

# To parse your grammar, pgen assumes that brackets inside of a code expression are balanced.
# Then it copy/pastes the contents into the parser inside a function. How exactly that happens is TBD.

# Instead of using an unbalancing { or }, use the macros LB or RB.
# Instead of using "{" or "}" use the macros LBSTR or RBSTR.
# This will keep the parser happy.

##########
# PARSER #
##########

# Rules
GrammarFile     <- (_ Definition)* _ EOF

Definition      <- RuleIdent _ StructDef? _ '<-' _ SlashExpr

StructDef       <- '{' (_ RuleIdent _ '[]'?)* _ '}'

SlashExpr       <- ModExprList (_ '/' ModExprList)*

ModExprList     <- (_ ModExpr)+

ModExpr         <- (RuleIdent _ '=' _)? (('&' / '!') _)? BaseExpr _ ('?' / '*' / '+')?

BaseExpr        <- TokIdent
                 / RuleIdent _ !'<-'
                 / CodeExpr
                 / '(' _ SlashExpr _ ')'


CodeExpr        <- '{' _ (&'{' CodeExpr / !'}' .)* _ '}'


# Misc
TokIdent        <- [_A-Z]+
RuleIdent       <- [_a-z]+
