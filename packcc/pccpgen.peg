
# Hierarchical syntax
Grammar <- Spacing Definition* Extensions
Definition <- Identifier LEFTARROW Expression
Expression <- (Prefix+) (SLASH Prefix+)*
Prefix <- (AND / NOT)? Primary (QUESTION / STAR / PLUS)?
        / LabelExt
Primary <- Identifier !LEFTARROW {}
         / OPEN Expression CLOSE
         / Literal / Class / DOT / CCodeExt

# Packcc Extension Syntax
Extensions <- EOF / Spacing (Extension Spacing)* EOF
Extension <- PrefixExt / ValueExt / AuxilExt / HeaderExt / EndCCodeExt
PrefixExt <- '%prefix' Spacing Literal
ValueExt <- '%value' Spacing Literal
AuxilExt <- '%auxil' Spacing Literal
HeaderExt <- '%header' Spacing CCodeExt Spacing
EndCCodeExt <- '%%' (!EOF .)* EOF
LabelExt <- Identifier ':' Identifier / Identifier ':' OPEN Identifier CLOSE
CCodeExt <- '{' Spacing (&'{' CCodeExt / !'}' .)* '}' Spacing

# Lexical syntax
EOF <- !.
EOL <- '\r\n' / '\n' / '\r'
SPACE <- ' ' / '\t' / EOL
PEGCOMMENT <- '#' (!EOL .)* EOL
DOT <- '.' Spacing
CLOSE <- ')' Spacing
OPEN <- '(' Spacing
PLUS <- '+' Spacing
STAR <- '*' Spacing
QUESTION <- '?' Spacing
NOT <- '!' Spacing
AND <- '&' Spacing
SLASH <- '/' Spacing
LEFTARROW <- '<-' Spacing
CHAR <- '\\' [nrt'"\[\]\\]
      / '\\' [0-2][0-7][0-7]
      / '\\' [0-7][0-7]?
      / !'\\' .
Spacing <- (SPACE / PEGCOMMENT)*
Range <- CHAR '-' CHAR / CHAR
Class <- '[' '^'? (!']' Range)* ']' Spacing
Literal <- "'" (!"'" CHAR)* "'" Spacing
         / '"' (!'"' CHAR)* '"' Spacing
IDENTSTART <- [a-zA-Z_]
IDENTCONT <- [a-zA-Z_0-9]
Identifier <- IDENTSTART IDENTCONT* Spacing


%prefix "peg"
%value "ASTNode*"
%auxil "auxil_t*"

%header {
#include "pccast.h"
#include <daisho/Daisho.h>

#define PCC_BUFFERSIZE (__DAI_PAGESIZE * 64)

typedef struct {
  __Dai_String_View target;
  void* ctx;
} auxil_t;

#define PCC_GETCHAR(auxil) nextChar(auxil)
static inline char nextChar(auxil_t* auxil) {
  if (auxil->target.str[auxil->target.len] == '\0') {
    return EOF;
  } else {
    char ret = auxil->target.str[auxil->target.len];
    auxil->target.len++;
    return ret;
  }
}

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) debugVisit(auxil, event, rule, level)
static inline void debugVisit(auxil_t* auxil, int event, char* rule, size_t level) {
  if (isupper(rule[2])) return;
  for (size_t i = 0; i < level; i++) printf("%c%c", ' ', ' ');
  /* Color eval, accept, reject */
  char* color =  event ? event == 1 ? __DAI_COLOR_GREEN : __DAI_COLOR_RED : __DAI_COLOR_BLUE;
  printf("%s%s%s\n", color, rule, __DAI_COLOR_RESET);
}

#define PCC_ERROR(auxil)
static inline void debugError(auxil_t* auxil) {
    puts("Syntax error:");
    puts(auxil->target.str + auxil->target.len);
}

}


%%

int main(int argc, char** argv) {

  // Load target file
  char* filename = argc == 2 ? argv[1] : "pgen.peg";
  auxil_t auxil;
  auxil.target = __Dai_readFile(filename);
  auxil.target.len = 0;

  // Initialize parser
  ASTNode* ast;
  peg_context_t* ctx = peg_create(&auxil);
  auxil.ctx = ctx;

  // Parse ast
  int parser_ret = peg_parse(ctx, &ast);

  peg_destroy(ctx);
  return 0;
}
